
---

### 📌 找出数组中第二大的数（简单稳健版）

```java
public class SecondLargest {
    public static void main(String[] args) {
        int[] arr = {10, 5, 8, 20, 20, 15, 9};

        // 初始化最大值和第二大值为最小可能值
        int first = Integer.MIN_VALUE;   // 最大值
        int second = Integer.MIN_VALUE;  // 第二大值

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > first) {
                // 找到新的最大值：原来的 first 变成 second
                second = first;
                first = arr[i];
            } else if (arr[i] > second && arr[i] != first) {
                // 找到介于 first 和 second 之间的新值，且不等于 first（去重）
                second = arr[i];
            }
        }

        // 判断是否存在有效的第二大值
        if (second == Integer.MIN_VALUE) {
            System.out.println("数组中没有第二大的数（所有元素相同或长度不足）");
        } else {
            System.out.println("第二大的数是: " + second);
        }
    }
}
```

#### 💡 示例输出（以上数组 `{10, 5, 8, 20, 20, 15, 9}`）：
```
第二大的数是: 15
```

#### 其他测试用例：
- `{5, 5, 5}` → 输出：**没有第二大的数**
- `{1, 2}` → 输出：**1**
- `{3}` → 输出：**没有第二大的数**

---

### 🔍 关键逻辑说明：
- 使用两个变量 `first` 和 `second` 跟踪最大和第二大。
- `arr[i] != first` 确保 **重复的最大值不会污染 second**。
- 初始化为 `Integer.MIN_VALUE` 可兼容负数。
- 最后检查 `second` 是否仍为初始值，判断是否存在有效第二大数。

---

### ⚠️ 注意事项：
- 此方法假设数组至少有两个**不同**的元素才有“第二大”。
- 不排序，时间复杂度为 **O(n)**，效率高。

---

### 🧪 小练习建议：
- 尝试改成找 **第二小的数**
- 改为支持 `double[]` 数组

---

## 📌 题目：找出两个字符串的最长公共子串

**题目描述**：  
给定两个字符串 `str1` 和 `str2`，找出它们**最长的连续公共子串**（必须连续！）。  
如果有多个相同长度的结果，返回任意一个即可。

**示例**：
- `str1 = "abcdxyz"`, `str2 = "xyzabcd"`  
  → 公共子串有 `"abcd"`（长度4）、`"xyz"`（长度3）  
  → 最长为 `"abcd"`（或 `"xyz"` 如果先找到，但长度最大是 4）

> ⚠️ 注意：**子串（Substring）必须连续**，不同于“子序列（Subsequence）”。

---

## 💡 方法一：暴力法（初学者友好）

### 思路
1. 枚举 `str1` 的所有子串（起始位置 i，结束位置 j）
2. 对每个子串，检查它是否在 `str2` 中出现（用 `contains()`）
3. 记录最长的那个

### ✅ 代码实现

```java
public class LongestCommonSubstring {

    public static String findLCS(String str1, String str2) {
        String longest = "";
        int len1 = str1.length();
        
        // 遍历 str1 的所有子串（从长到短可提前终止，但这里从短到长也行）
        for (int i = 0; i < len1; i++) {
            for (int j = i + 1; j <= len1; j++) {
                String substr = str1.substring(i, j);
                // 如果 substr 在 str2 中，且比当前最长的还长
                if (str2.contains(substr) && substr.length() > longest.length()) {
                    longest = substr;
                }
            }
        }
        return longest;
    }

    public static void main(String[] args) {
        String s1 = "abcdxyz";
        String s2 = "xyzabcd";
        String result = findLCS(s1, s2);
        System.out.println("最长公共子串: \"" + result + "\" (长度: " + result.length() + ")");
        // 输出可能是 "abcd" 或 "xyz"，取决于遍历顺序（这里会是 "abcd"）
    }
}
```

### ⏱️ 复杂度
- 时间复杂度：O(n³)  
  （两层循环 O(n²)，`substring` + `contains` 最坏 O(n)）
- 空间复杂度：O(n)（存储子串）

> ✅ 优点：代码简单，逻辑清晰  
> ❌ 缺点：效率低，不适合长字符串

---

## 💡 方法二：动态规划（DP）优化（推荐了解）

### 思路
- 定义 `dp[i][j]` 表示以 `str1[i-1]` 和 `str2[j-1]` 结尾的**公共子串长度**
- 状态转移：
  - 如果 `str1[i-1] == str2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`
  - 否则 `dp[i][j] = 0`
- 同时记录最大长度和结束位置，最后截取子串

### ✅ 代码实现

```java
public class LongestCommonSubstringDP {

    public static String findLCS(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        int maxLength = 0;
        int endingPos = 0; // 在 str1 中的结束位置

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    if (dp[i][j] > maxLength) {
                        maxLength = dp[i][j];
                        endingPos = i; // 记录在 str1 中的结束索引
                    }
                } else {
                    dp[i][j] = 0;
                }
            }
        }

        // 如果 maxLength 为 0，说明无公共子串
        if (maxLength == 0) return "";
        return str1.substring(endingPos - maxLength, endingPos);
    }

    public static void main(String[] args) {
        String s1 = "abcdxyz";
        String s2 = "xyzabcd";
        System.out.println("最长公共子串: \"" + findLCS(s1, s2) + "\"");
        // 输出 "abcd"（因为它是第一个达到长度4的）
    }
}
```

### ⏱️ 复杂度
- 时间复杂度：O(m × n)
- 空间复杂度：O(m × n)（可用滚动数组优化到 O(n)，但初学者可暂缓）

> ✅ 优点：效率高，适合较长字符串  
> ✅ 是面试常见解法

---

## 🧪 边界测试用例

| str1 | str2 | 最长公共子串 | 长度 |
|------|------|-------------|-----|
| `"abcdxyz"` | `"xyzabcd"` | `"abcd"` 或 `"xyz"` | 4 |
| `"hello"` | `"world"` | `"l"` 或 `"o"` | 1 |
| `"abc"` | `"def"` | `""` | 0 |
| `"same"` | `"same"` | `"same"` | 4 |
| `""` | `"abc"` | `""` | 0 |

---

## 📚 知识点总结

| 概念 | 说明 |
|------|------|
| `String.substring(i, j)` | 截取 `[i, j)` 的子串 |
| `String.contains()` | 判断是否包含某子串（内部用 indexOf）|
| 动态规划（DP） | 用表格记录中间结果，避免重复计算 |
| 子串 vs 子序列 | 子串必须连续，子序列可以不连续 |
| 二维数组 `dp[i][j]` | 表示以 i 和 j 结尾的状态 |

---

## 🧠 练习建议

1. **先掌握暴力法**：确保你能手写出来
2. **尝试 DP 法**：画一个 `dp` 表格手动模拟（如 `"abc"`, `"acb"`）
3. **扩展问题**：
   - 返回**所有**最长公共子串（去重）
   - 找出最长公共**子序列**（LCS，不要求连续）

---


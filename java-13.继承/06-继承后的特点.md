
---

## 📌 继承后的特点

> 当一个类通过 `extends` 继承另一个类后，会带来一系列**结构性、行为性和语义性**的变化。  
> 理解这些特点是掌握面向对象编程（OOP）的关键一步。

---

### ✅ 1. **成员的继承性**

子类自动**继承父类的非私有成员**（字段和方法）。

```java
class Animal {
    protected String name;        // ✅ 被继承
    public void eat() { }         // ✅ 被继承
    private int age;              // ❌ 不被继承（但可通过 getter/setter 间接访问）
}

class Dog extends Animal {
    public void bark() {
        System.out.println(name + " 汪汪叫"); // 直接使用继承的 name
        eat(); // 直接调用继承的方法
    }
}
```

> 🔑 规则：
> - `public` / `protected`：**一定继承**
> - `default`（包私有）：**同包内继承**
> - `private`：**不继承**（但存在于子类对象内存中，只是不可见）

---

### ✅ 2. **构造过程：先父后子**

创建子类对象时，**先初始化父类，再初始化子类**。

```java
class Animal {
    public Animal() {
        System.out.println("Animal 构造");
    }
}

class Dog extends Animal {
    public Dog() {
        System.out.println("Dog 构造");
    }
}

// new Dog(); 输出：
// Animal 构造
// Dog 构造
```

> ⚠️ 每个子类构造方法**第一行隐含 `super()`**  
> 若父类无无参构造，必须**显式调用** `super(...)`。

---

### ✅ 3. **方法重写（Override）支持多态**

子类可重写父类方法，实现**运行时多态**。

```java
Animal a = new Dog(); // 父类引用指向子类对象
a.eat(); // 调用的是 Dog 的 eat()（如果重写了）
```

> 🔑 多态三要素：
> 1. 继承关系  
> 2. 方法重写  
> 3. 父类引用指向子类对象

---

### ✅ 4. **`this` 与 `super` 的作用域**

| 关键字 | 作用 |
|--------|------|
| `this` | 指向**当前子类对象**，可访问子类和继承的父类成员 |
| `super` | 显式调用**父类的成员**（字段、方法、构造器） |

```java
class Animal {
    protected String name = "动物";
    public void speak() { System.out.println("动物发声"); }
}

class Dog extends Animal {
    private String name = "狗";

    public void info() {
        System.out.println(this.name);   // 输出：狗（子类字段）
        System.out.println(super.name);  // 输出：动物（父类字段）
    }

    @Override
    public void speak() {
        super.speak(); // 先调用父类方法
        System.out.println("汪汪！");   // 再扩展
    }
}
```

---

### ✅ 5. **对象内存结构：父类 + 子类**

一个子类对象在堆内存中包含：
- **父类部分**（所有继承的字段）
- **子类部分**（自己定义的字段）

> 🧠 虽然 `private` 字段不被“继承”（不可见），但**仍然存在于子类对象中**！

```java
class Parent {
    private int x = 10;
}

class Child extends Parent {
    public void printX() {
        // System.out.println(x); // ❌ 编译错误
        // 但 x 仍然存在于 Child 对象的内存中！
    }
}
```

---

### ✅ 6. **类型兼容性：向上转型（Upcasting）**

子类对象可**自动转换为父类类型**（安全）。

```java
Dog dog = new Dog();
Animal animal = dog; // ✅ 向上转型（隐式）
```

> ⚠️ 但**不能自动向下转型**（需强制转换，且有风险）：
> ```java
> Animal a = new Dog();
> Dog d = (Dog) a; // ✅ 安全（实际是 Dog）
> 
> Animal b = new Cat();
> Dog d2 = (Dog) b; // ❌ 运行时抛 ClassCastException！
> ```

---

### ✅ 7. **静态成员不参与继承多态**

- 静态方法/变量属于**类**，不是对象
- 子类同名静态成员会**隐藏（Hide）** 父类成员，而非重写

```java
class Parent {
    public static void show() { System.out.println("Parent"); }
}

class Child extends Parent {
    public static void show() { System.out.println("Child"); }
}

Parent p = new Child();
p.show(); // 输出：Parent（静态绑定，看引用类型！）
```

> 🔑 静态方法**不支持多态**！

---

### 🚫 继承的限制（Java 特性）

| 限制 | 说明 |
|------|------|
| **单继承** | 一个类只能有一个直接父类（`class A extends B`） |
| **不能继承构造方法** | 但可通过 `super()` 调用 |
| **不能继承 `private` 成员** | 但它们存在于对象中 |
| **`final` 类不能被继承** | 如 `String`, `Math` |

> 💡 多行为复用 → 使用 **接口（Interface）**

---

### 🏷️ Obsidian 标签建议
```markdown
#Java #继承 #继承特点 #面向对象 #多态 #super #this #内存模型 #Java11
```


---


  ```markdown
  继承后支持 [[方法的重写]]，是实现 [[多态]] 的基础；对象创建时遵循 [[先父后子]] 的构造顺序。
  ```

---

### ✅ 总结口诀
> **“继承得成员，构造先父后；  
> this 指自己，super 找父类；  
> 多态靠重写，静态不参与；  
> 向上可转型，单继承要记住。”**

---

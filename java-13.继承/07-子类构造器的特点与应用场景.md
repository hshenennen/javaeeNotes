帮助你掌握子类构造器的核心规则、初始化流程及其在实际开发中的典型用途。

---

## 📌 继承-子类构造器的特点与应用场景

> 在 Java 继承体系中，**子类构造器** 不仅负责初始化自身成员，还必须**协同父类完成完整对象的构建**。  
> 理解其特点，是避免初始化错误、设计健壮类层次结构的关键。

---

### ✅ 一、子类构造器的核心特点

#### 1. **隐式调用父类构造器（`super()`）**
- 若子类构造器**未显式调用**父类构造器，编译器会**自动插入 `super()`**（调用父类无参构造）
- `super()` 必须是子类构造器的**第一条语句**

```java
class Animal {
    public Animal() {
        System.out.println("Animal 构造");
    }
}

class Dog extends Animal {
    public Dog() {
        // 编译器自动插入：super();
        System.out.println("Dog 构造");
    }
}
```

> 输出：
> ```
> Animal 构造
> Dog 构造
> ```

#### 2. **必须显式调用父类有参构造（当父类无无参构造时）**
```java
class Animal {
    public Animal(String name) { // 无无参构造
        System.out.println("Animal: " + name);
    }
}

class Dog extends Animal {
    public Dog(String name) {
        super(name); // ✅ 必须显式调用
    }
}
```

> ❌ 若省略 `super(name)` → **编译错误！**

#### 3. **不能同时使用 `this()` 和 `super()`**
- `this()`：调用本类其他构造器
- `super()`：调用父类构造器
- 二者都必须是**第一条语句**，故**不能共存**

```java
class Dog extends Animal {
    public Dog() {
        this("未知"); // 调用本类另一个构造器
    }

    public Dog(String name) {
        super(name); // 调用父类构造器
    }
}
```

> ✅ 合法：通过 `this()` 间接完成 `super()` 调用

---

### 🔁 二、对象创建时的初始化顺序（重要！）

当执行 `new SubClass(...)` 时，初始化按以下顺序进行：

1. **父类静态成员**（类加载时执行一次）
2. **子类静态成员**
3. **父类实例成员初始化**（字段赋值）
4. **父类构造器执行**
5. **子类实例成员初始化**
6. **子类构造器执行**

```java
class Animal {
    { System.out.println("Animal 实例初始化块"); }
    public Animal() { System.out.println("Animal 构造器"); }
}

class Dog extends Animal {
    { System.out.println("Dog 实例初始化块"); }
    public Dog() { System.out.println("Dog 构造器"); }
}

// new Dog() 输出：
// Animal 实例初始化块
// Animal 构造器
// Dog 实例初始化块
// Dog 构造器
```

> 💡 记忆口诀：**“静父 → 静子 → 实父 → 构父 → 实子 → 构子”**

---

### 🌐 三、典型应用场景

#### 场景 1：**强制子类提供必要参数给父类**
> 父类定义通用属性，子类必须在构造时传入

```java
abstract class Vehicle {
    protected String brand;
    public Vehicle(String brand) {
        this.brand = brand;
    }
}

class Car extends Vehicle {
    private int doors;
    public Car(String brand, int doors) {
        super(brand); // 确保品牌被初始化
        this.doors = doors;
    }
}
```

#### 场景 2：**模板化对象创建（模板方法模式雏形）**
> 父类构造器执行通用初始化逻辑，子类补充特有逻辑

```java
class BaseService {
    protected Logger logger;
    public BaseService() {
        this.logger = LoggerFactory.getLogger(getClass());
        logger.info("服务 {} 已初始化", getClass().getSimpleName());
    }
}

class OrderService extends BaseService {
    public OrderService() {
        // 父类已初始化日志
        System.out.println("订单服务启动");
    }
}
```

#### 场景 3：**不可变对象（Immutable）的继承安全初始化**
> 通过构造器一次性设置所有字段（包括继承的）

```java
class Point {
    protected final int x, y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class ColorPoint extends Point {
    private final String color;
    public ColorPoint(int x, int y, String color) {
        super(x, y); // 初始化父类 final 字段
        this.color = color;
    }
}
```

> ✅ 保证对象创建后状态完整且不可变

---

### ⚠️ 四、常见误区与注意事项

| 误区 | 正确理解 |
|------|--------|
| “子类构造器会自动继承父类构造器” | ❌ 构造器**不会被继承**，只能通过 `super()` 调用 |
| “可以在构造器中调用非 final 的重写方法” | ⚠️ 危险！子类重写方法可能访问未初始化的字段 |
| “`super()` 可以放在构造器任意位置” | ❌ 必须是**第一条语句** |
| “父类无构造器，子类可随意构造” | ❌ 若父类无**无参构造**，子类必须显式调用 `super(...)` |

> 🔥 **危险示例**（避免在构造器中调用可重写方法）：
```java
class Parent {
    public Parent() {
        print(); // 调用可能被重写的方法
    }
    void print() { System.out.println("Parent"); }
}

class Child extends Parent {
    private String name = "Child";
    @Override
    void print() {
        System.out.println(name); // 此时 name 还未初始化！输出 null
    }
}
```

---

### 🏷️ Obsidian 标签建议
```markdown
#Java #继承 #构造器 #子类构造器 #super #初始化顺序 #面向对象 #Java11
```

---

  ```markdown
  子类构造器通过 [[super 关键字]] 调用父类构造器，遵循 [[继承后的特点]] 中的“先父后子”初始化顺序，是构建完整对象的基础。
  ```

---

### ✅ 总结口诀
> **“子类构造先父类，super 必须第一行；  
> 无参自动有参显，this super 不共存；  
> 初始化顺序要记清，构造勿调重写法；  
> 参数传递保完整，安全构建靠它行。”**

---


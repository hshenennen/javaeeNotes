帮助你系统化地掌握面向对象编程中核心的 **继承（Inheritance）** 概念。

---

# 📘 Java 13 继承学习指南  
> **目标：理解继承的本质，掌握访问控制、方法重写、super 关键字等核心机制**

---

## 📌 学习路径概览

| 序号 | 主题 | 核心目标 |
|------|------|----------|
| 01 | 认识继承 | 理解继承的概念和意义 |
| 02 | 访问修饰符 | 掌握 `private`、`protected`、`public` 的作用域 |
| 03 | 方法的重写 | 学会重写父类方法，实现多态 |
| 04 | 方法重写-应用场景 | 理解重写的实际用途 |
| 05 | super 关键字 | 掌握 `super()` 和 `super.method()` 的使用 |
| 06 | 继承后的特点 | 理解继承带来的行为变化 |
| 07 | 类构造器的特点与应用 | 掌握子类构造器的初始化顺序 |
| 08 | 构造器用 this 调用兄弟构造器 | 理解构造器链的构建方式 |

> ✅ **建议学习顺序**：严格按此顺序进行，每一步都为基础！

---

## 🔍 每章预习与学习指南

---

### 📘 [[01-认识继承]]

#### ✅ 预习问题
- 什么是“继承”？它和“复制代码”有什么区别？
- 继承能解决什么问题？
- 为什么需要继承？

#### 🧠 核心知识点
- **继承 = “is-a” 关系**  
  - 如：`Dog is a Animal`
  - 表示子类是父类的一种特殊类型
- **代码复用**：子类自动获得父类的字段和方法
- **扩展性**：在不修改父类的情况下，添加新功能

```java
class Animal {
    protected String name;
    public void eat() {
        System.out.println(name + " 在吃东西");
    }
}

class Dog extends Animal { // 继承 Animal
    public void bark() {
        System.out.println(name + " 在叫");
    }
}
```

> ✅ 使用：
```java
Dog d = new Dog();
d.name = "旺财";
d.eat(); // 继承自 Animal
d.bark(); // 自己的方法
```

#### 💡 学习建议
- 写一个 `Cat` 类继承 `Animal`
- 创建多个动物对象，观察共性与差异

---

### 📘 [[02-访问修饰符]]

#### ✅ 预习问题
- `private`、`protected`、`public` 分别是什么意思？
- 子类能访问父类的私有字段吗？
- 不同修饰符的访问范围如何？

#### 🧠 核心知识点
| 修饰符 | 同类 | 同包 | 不同包 | 子类 |
|--------|------|------|--------|------|
| `private` | ✅ | ❌ | ❌ | ❌ |
| `default`（无） | ✅ | ✅ | ❌ | ❌ |
| `protected` | ✅ | ✅ | ✅ | ✅ |
| `public` | ✅ | ✅ | ✅ | ✅ |

> ⚠️ 注意：
- 子类只能访问父类的 `public` 和 `protected` 成员
- `private` 字段不能被直接访问，但可通过 `getter/setter` 间接访问

```java
class Parent {
    private String secret;     // 子类无法访问
    protected String info;     // 子类可以访问
    public String publicData;  // 所有都能访问
}

class Child extends Parent {
    // 可以访问 info 和 publicData
    // 不能访问 secret → 编译错误
}
```

#### 💡 学习建议
- 创建一个 `Person` 类，包含 `private` 和 `protected` 字段
- 尝试在子类中访问它们 → 观察编译结果

---

### 📘 [[03-方法的重写]]

#### ✅ 预习问题
- 什么是“方法重写”？它和“方法重载”有什么区别？
- 什么时候需要重写父类方法？
- 重写后，父类方法还能调用吗？

#### 🧠 核心知识点
- **重写（Override）**：子类重新定义父类已存在的方法
- 必须满足：
  - 方法名相同
  - 参数列表相同
  - 返回值类型相同或子类型（协变返回）
  - 访问权限不能更严格（可更宽松）

```java
class Animal {
    public void speak() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("汪汪！");
    }
}
```

> ✅ 使用：
```java
Animal a = new Dog();
a.speak(); // 输出：汪汪！→ 多态体现
```

#### 💡 学习建议
- 重写 `toString()` 方法（见后续章节）
- 尝试改变返回类型 → 编译错误！

---

### 📘 [[04-方法重写-应用场景：toString() 方法]]

#### ✅ 预习问题
- 重写 `toString()` 有什么好处？
- 重写 `equals()` 和 `hashCode()` 是为了什么？
- 重写 `clone()` 用于什么场景？

#### 🧠 核心知识点
| 场景 | 说明 |
|------|------|
| **`toString()`** | 提供对象的可读字符串表示，便于调试和日志 |
| **`equals()`** | 判断两个对象是否逻辑相等（如内容相同） |
| **`hashCode()`** | 保证 `equals()` 相等的对象有相同的哈希码，用于集合类（如 `HashSet`, `HashMap`） |
| **`clone()`** | 创建对象副本，实现深拷贝/浅拷贝 |

```java
@Override
public String toString() {
    return "Student{name='" + name + "', age=" + age + "}";
}

@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Student student = (Student) obj;
    return age == student.age && Objects.equals(name, student.name);
}

@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```

#### 💡 学习建议
- 为 `Student` 类重写这三个方法
- 测试：`new Student("A", 18).equals(new Student("A", 18))` → 是否为 `true`？

---

### 📘 [[05-super 关键字]]

#### ✅ 预习问题
- `super` 是什么？它指向谁？
- `super()` 和 `super.method()` 有什么区别？
- 什么时候用 `super`？

#### 🧠 核心知识点
| 用法 | 说明 |
|------|------|
| `super()` | 调用父类无参构造器 |
| `super(param)` | 调用父类有参构造器 |
| `super.method()` | 调用父类被重写的方法 |

```java
class Animal {
    protected String name;
    public Animal(String name) {
        this.name = name;
    }
    public void sleep() {
        System.out.println(name + " 在睡觉");
    }
}

class Dog extends Animal {
    public Dog(String name) {
        super(name); // 调用父类构造器
    }

    @Override
    public void sleep() {
        super.sleep(); // 调用父类方法
        System.out.println("狗睡得香");
    }
}
```

#### 💡 学习建议
- 在 `sleep()` 中调用 `super.sleep()`，观察输出顺序
- 尝试在构造器中省略 `super()` → 编译错误！

---

### 📘 [[06-继承后的特点]]

#### ✅ 预习问题
- 子类继承了父类的所有成员吗？
- 父类的 `private` 成员能被子类访问吗？
- 继承后，对象的内存结构是怎样的？

#### 🧠 核心知识点
| 特点 | 说明 |
|------|------|
| **继承所有非私有成员** | 包括字段、方法、构造器（但不包括 `private`） |
| **`private` 成员不可直接访问** | 但可通过 `getter/setter` 间接访问 |
| **方法重写优先级更高** | 子类重写的方法覆盖父类方法 |
| **多态性** | 父类引用指向子类对象，运行时调用子类方法 |

```java
Animal a = new Dog(); // 多态
a.speak(); // 调用 Dog 的 speak()
```

#### 💡 学习建议
- 创建 `Animal` 和 `Dog` 对象，测试 `instanceof`
- 观察 `a instanceof Dog` 是否为 `true`

---

### 📘 [[07-子类构造器的特点与应用场景]]

#### ✅ 预习问题
- 子类构造器执行前，父类构造器会执行吗？
- 构造器的执行顺序是怎样的？
- 如果父类没有无参构造器，子类怎么办？

#### 🧠 核心知识点
**初始化顺序**：
1. 父类静态成员初始化
2. 子类静态成员初始化
3. 父类实例成员初始化
4. 父类构造器执行
5. 子类实例成员初始化
6. 子类构造器执行

> ✅ 示例：
```java
class Parent {
    { System.out.println("Parent 实例块"); }
    public Parent() { System.out.println("Parent 构造器"); }
}

class Child extends Parent {
    { System.out.println("Child 实例块"); }
    public Child() { System.out.println("Child 构造器"); }
}
```

> 输出：
```
Parent 实例块
Parent 构造器
Child 实例块
Child 构造器
```

#### 💡 学习建议
- 添加静态块，观察加载顺序
- 尝试在子类构造器中调用 `super()` → 确保父类先初始化

---

### 📘 [[08-构造器用 this调用兄弟构造器]]

#### ✅ 预习问题
- `this()` 是什么？它和 `super()` 有什么关系？
- 为什么可以在构造器中调用另一个构造器？
- 构造器链是如何工作的？

#### 🧠 核心知识点
- `this(...)`：调用本类其他构造器（兄弟构造器）
- 必须是第一条语句
- 不能与 `super()` 共存
- 最终必须通过 `super()` 或默认构造器完成父类初始化

```java
class Dog extends Animal {
    public Dog() {
        this("未知"); // 调用兄弟构造器
    }

    public Dog(String name) {
        super(name); // 调用父类构造器
    }
}
```

> ✅ 执行 `new Dog()` 时：
1. `Dog()` → `this("未知")`
2. `Dog("未知")` → `super("未知")`
3. 父类构造器执行
4. 返回执行剩余代码

#### 💡 学习建议
- 写一个 `Car` 类，包含多个构造器
- 使用 `this()` 减少重复代码
- 尝试把 `this()` 放在第二行 → 编译错误！

---

## ✅ 总结口诀
> **“继承是 is-a，代码复用强；  
> 访问修饰要记清，private 不可见；  
> 方法重写改行为，super 调父类；  
> 构造链有序，先父后子记。”**

---

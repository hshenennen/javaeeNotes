
---

## 📌 方法的重写（Method Overriding）

> **方法重写** 是子类对父类中**已存在的非私有、非静态、非 final 方法**进行**重新定义**的过程。  
> 它是实现 **运行时多态（动态绑定）** 的关键手段。

---

### ✅ 为什么需要方法重写？

- 父类方法无法满足子类特定需求  
- 实现“**通用接口，不同实现**”的设计思想  
- 支持多态：**同一个方法调用，不同对象表现出不同行为**

```java
Animal a1 = new Dog();
Animal a2 = new Cat();
a1.makeSound(); // 输出：汪汪！
a2.makeSound(); // 输出：喵喵！
```

---

### 🔧 重写的规则（必须同时满足！）

| 条件 | 说明 |
|------|------|
| **1. 方法名相同** | 子类方法名必须与父类一致 |
| **2. 参数列表相同** | 包括参数类型、个数、顺序 |
| **3. 返回类型兼容** | Java 5+：可为**协变返回类型**（子类返回类型是父类返回类型的子类） |
| **4. 访问权限不能更严格** | 如父类是 `protected`，子类不能是 `private` |
| **5. 不能重写 `static` 方法** | 静态方法属于类，不参与多态（子类同名方法叫“隐藏”） |
| **6. 不能重写 `final` / `private` 方法** | `final` 禁止重写，`private` 对子类不可见 |

> ✅ 正确示例：
```java
class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override // ← 强烈建议加上，编译器会校验
    public void makeSound() {
        System.out.println("汪汪！");
    }
}
```

---

### 🚫 不能重写的情况（常见错误）

| 情况 | 示例 | 说明 |
|------|------|------|
| **父类方法是 `private`** | `private void run()` | 子类看不见，不算重写 |
| **父类方法是 `static`** | `static void jump()` | 子类定义同名方法 → **方法隐藏（Hiding）** |
| **父类方法是 `final`** | `final void eat()` | 明确禁止重写 |
| **参数列表不同** | `void run(int speed)` vs `void run()` | 这是 **方法重载（Overload）**，不是重写 |

---

### 🎯 `@Override` 注解的作用

- **显式声明**：告诉阅读者“这是一个重写方法”
- **编译检查**：如果父类没有对应方法，编译报错
- **防止拼写错误**：如把 `toString()` 写成 `tostring()`

```java
class Student {
    @Override
    public String toString() {
        return "Student{name='小明'}";
    }

    // @Override
    // public void tostring() { } // ❌ 编译错误！因为父类没有 tostring()
}
```

> 💡 **强烈建议**：所有重写方法都加上 `@Override`

---

### 🔁 重写 vs 重载（对比表）

| 特性 | 方法重写（Overriding） | 方法重载（Overloading） |
|------|----------------------|------------------------|
| **发生位置** | 子类 与 父类 | 同一个类中 |
| **方法名** | 必须相同 | 必须相同 |
| **参数列表** | 必须相同 | 必须不同 |
| **返回类型** | 必须兼容（或相同） | 无关（可相同可不同） |
| **访问修饰符** | 不能更严格 | 无关 |
| **多态支持** | ✅ 运行时多态 | ❌ 编译时绑定 |
| **关键字** | `@Override` | 无 |
| **目的** | 扩展/修改父类行为 | 提供多种调用方式 |

---

### 💡 多态与重写的经典示例

```java
class Shape {
    public void draw() {
        System.out.println("绘制一个形状");
    }
}

class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("绘制一个圆形");
    }
}

class Rectangle extends Shape {
    @Override
    public void draw() {
        System.out.println("绘制一个矩形");
    }
}

// 多态调用
public class Main {
    public static void main(String[] args) {
        Shape s1 = new Circle();
        Shape s2 = new Rectangle();

        s1.draw(); // 输出：绘制一个圆形
        s2.draw(); // 输出：绘制一个矩形
    }
}
```

> ✅ **核心**：编译看左边（`Shape`），运行看右边（实际对象类型）

---

### ⚠️ 注意事项

1. **构造方法不能被重写**  
   - 构造方法名 = 类名，子类和父类类名不同

2. **重写方法可以抛出更少或相同的异常**  
   - 但不能抛出**更多或更宽泛的检查异常**
   ```java
   class Parent {
       void method() throws IOException { }
   }
   class Child extends Parent {
       @Override
       void method() { } // ✅ 可以不抛异常
       // void method() throws Exception { } // ❌ 编译错误！
   }
   ```

3. **重写是实现接口多态的基础**  
   - 接口中的抽象方法必须在实现类中“重写”

---

### 🏷️ Obsidian 标签建议
```markdown
#Java #方法重写 #Overriding #多态 #继承 #面向对象 #Java11 #@Override
```

---


  ```markdown
  方法重写是实现 [[多态]] 的核心机制，必须发生在 [[继承]] 关系中。
  ```

---

### ✅ 总结口诀
> **“重写看父子，方法要一致；  
> 名同参同返兼容，权限不能更严格；  
> static final 不能动，@Override 来护航；  
> 多态靠它来实现，运行绑定显神通。”**

---
